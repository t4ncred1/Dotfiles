#+TITLE: t4ncred1's Emacs Literate Configuration
#+AUTHOR: t4ncred1
#+PROPERTY: header-args :tangle config.el :comments link

* Introduction
:PROPERTIES:
:VISIBILITY: children
:END:

** About this file
This is an Emacs /literate configuration/ file.  It contains code
snippets that get tangled together to create a configuration file The
name of the configuration file is stored in the elisp variable
=t4n/config-file=.

** Personal information
Let's set some variables with basic user informations.

#+begin_src emacs-lisp
  (setq user-full-name "Tancredi Covioli"
	user-mail-address "tancredi.covioli@gmail.com")
#+end_src

** Special thanks
The following resources were of inspiration in the making of this
configuration:
- [[https://raw.githubusercontent.com/frap/emacs-literate/master/readme.org][Atea Emacs Literate Configuration]]

* Emacs general configuration
In this section we gathered all the customizations that do not require
an additional package to work.

** Separate file for Customize
By default, the =customize= interface writes its modifications to
=~/.emacs.d/init.el=.  What we would prefer instead is to write these
modifications on an ad-hoc file.

#+begin_src emacs-lisp
  (setq custom-file (expand-file-name "custom.el" user-emacs-directory))
  (if (file-exists-p custom-file)
      (load custom-file))
#+end_src

** Change the bell
Let's change the way emacs notifies us that we made a mistake.

By default, the whole screen flashes wenever we input an unassigned
key combination or we abort a command through =C-g=. We can change
this behavior by modifying the variable =visible-bell=.

What we would like instead would be to have only the modeline flash a
couple of times in a small time frame.

#+begin_src emacs-lisp
  (setq visible-bell nil
	ring-bell-function 'double-flash-mode-line)
  (defun double-flash-mode-line ()
    (let ((flash-sec (/ 1.0 20)))
      (invert-face 'mode-line)
      (run-with-timer flash-sec nil #'invert-face 'mode-line)
      (run-with-timer (* 2 flash-sec) nil #'invert-face 'mode-line)
      (run-with-timer (* 3 flash-sec) nil #'invert-face 'mode-line)))
#+end_src

* Package Management  
In this section the set up process for package management is
described.

To install and configure packages we will use =use-package=, which
(when correctly set up) will speed up the initialization process.

** Package Settings
We're going to set the =load-path= ourselves and avoid calling
=(package-initilize)= (for performance reasons) so we need to set
=package--init-file-ensured= to true to tell =package.el= to not
automatically call it on our behalf. Additionally, we're setting
=package-enable-at-startup= to nil so that packages will not
automatically be loaded for us since =use-package= will be handling
that.

#+begin_src emacs-lisp
  (eval-and-compile
    (setq load-prefer-newer t
          package-user-dir "~/.emacs.d/elpa"
          package--init-file-ensured t
          package-enable-at-startup nil)

    (unless (file-directory-p package-user-dir)
      (make-directory package-user-dir t)))
#+end_src

** Manually Set Load Path
We're going to set the load path ourselves so that we don't have to
call =package-initialize= at runtime and incur a large performance
hit. This load-path will actually be faster than the one created by
=package-initialize= because it appends the elpa packages to the end
of the load path. Otherwise, any time a builtin package was required,
it would have to search all of third party paths first.

#+begin_src emacs-lisp
  (eval-and-compile
    (setq load-path (append load-path (directory-files package-user-dir t "^[^.]" t))))
#+end_src

** Initialise Package Management
Next we are going to require =package.el= and add our additional
package archives, 'melpa' and 'org'.  Afterwards, we need to
initialize our packages and then ensure that =use-package= is
installed, which we promptly install if it's missing. Finally we load
=use-package= and tell it to always install any missing packages.

Note that this entire block is wrapped in =eval-when-compile=. The
effect of this is to perform all of the package initialization during
compilation so that when byte compiled, all of this time consuming
code is skipped. This can be done because the result of byte compiling
=use-package= statements results in the macro being fully expanded at
which point =use-package= isn't actually required any longer.

Since the code is automatically compiled during runtime, if the
configuration hasn't already been previously compiled manually then
all of the package initialization will still take place at startup.

#+begin_src emacs-lisp
  (eval-when-compile
    (require 'package)

    (unless (assoc-default "melpa" package-archives)
      (add-to-list 'package-archives '("melpa" . "http://melpa.org/packages/") t))
    (unless (assoc-default "org" package-archives)
      (add-to-list 'package-archives '("org" . "http://orgmode.org/elpa/") t))
    (unless (package-installed-p 'use-package)
      (package-refresh-contents)
      (package-install 'use-package))
    (unless (package-installed-p 'bind-key)
      (package-refresh-contents)
      (package-install 'bind-key))
    (require 'use-package)
    (require 'bind-key)
    (setq use-package-always-ensure t))
#+end_src

** Set up Use-Package
Tell =use-package= to always defer loading packages unless explicitly
told otherwise. This speeds up initialization significantly as many
packages are only loaded later when they are explicitly used.

#+begin_src emacs-lisp
  (setq use-package-always-defer t
        use-package-verbose t)
#+end_src

* Windows management                                                :keybind:
The only available command to switch between windows is
=other-window=. While great for two windows, it loses its value when
there are multiple windows.  Introduce [[https://github.com/abo-abo/ace-window][ace-window]], an emacs package to
move and operate on windows faster.

#+begin_src emacs-lisp
  (use-package ace-window
    :bind ("M-o" . ace-window))
#+end_src
